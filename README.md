
Домашнее задание к занятию «Введение в Terraform»

Terraform  установлен.

root@TestDebian11:/opt/terraform# terraform --version
Terraform v1.5.1
on linux_amd64
+ provider registry.terraform.io/hashicorp/random v3.5.1
+ provider registry.terraform.io/kreuzwerker/docker v3.0.2




Задание 1

2. Изучите файл .gitignore. В каком terraform файле согласно этому .gitignore допустимо сохранить личную, секретную информацию?

personal.auto.tfvars

3. Выполните код проекта. Найдите в State-файле секретное содержимое созданного ресурса random_password, пришлите в качестве ответа конкретный ключ и его значение.

"result": "75oXigVQEGAGP1Tt"

4. Раскомментируйте блок кода, примерно расположенный на строчках 29-42 файла main.tf. Выполните команду terraform validate. Объясните в чем заключаются намеренно допущенные ошибки? Исправьте их.

Ошибка 1

Неправильно (отсутствует лабел. добавил лабел "nginx" ) :
resource "docker_image"  {
  name         = "nginx:latest"
  keep_locally = true
}

Правильно:
resource "docker_image" "nginx" {
  name         = "nginx:latest"
  keep_locally = true
}


Ошибка 2

Неправильно (название лейбла должно начинаться с буквы или подчеркивания, "1nginx" начинается с цифры 1  ):
resource "docker_container" "1nginx" {
  image = docker_image.nginx.image_id
  name  = "example_${random_password.random_string_fake.resuld}"

Правильно:
resource "docker_container" "nginx" {
  image = docker_image.nginx.image_id
  name  = "example_${random_password.random_string_fake.resuld}"

  
Ошибка 3

Неправильно (строка resource "random_password" "random_string" не совпадает со строкой  name  = "example_${random_password.random_string_fake.resuld}" хотя можно изменить строку  ):
name  = "example_${random_password.random_string_fake.resuld}"  по аналогии с resource "random_password" "random_string" т.е сделать name  = "example_${random_password.random_string.resuld}" 

resource "random_password" "random_string" {
resource "random_password" "random_string_fake" {
  length      = 16
  special     = false
  min_upper   = 1
  min_lower   = 1
  min_numeric = 1
}

resource "docker_container" "1nginx" {
  image = docker_image.nginx.image_id
  name  = "example_${random_password.random_string_fake.resuld}"

  
Правильно:

resource "random_password" "random_string_fake" {
  length      = 16
  special     = false
  min_upper   = 1
  min_lower   = 1
  min_numeric = 1
}


resource "docker_container" "nginx" {
  image = docker_image.nginx.image_id
  name  = "example_${random_password.random_string_fake.resuld}"  
  
  
 Ошибка 4 
 Неправильно. Неверно указана последняя буква в строке   name  = "example_${random_password.random_string_fake.resuld}". Нужно указать букву t .
  
 Правильно. 
  resource "docker_container" "nginx" {
  image = docker_image.nginx.image_id
  name  = "example_${random_password.random_string_fake.result}" 
  
 
5. Выполните код. В качестве ответа приложите вывод команды docker ps 
CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                  NAMES
488b2bf41d4d   a7be6198544f   "/docker-entrypoint.…"   13 minutes ago   Up 13 minutes   0.0.0.0:8000->80/tcp   example_9hC1T4SAmr5fOtxR

6. Замените имя docker-контейнера в блоке кода на hello_world, выполните команду terraform apply -auto-approve. Объясните своими словами, в чем может быть опасность применения ключа -auto-approve ? 
В качестве ответа дополнительно приложите вывод команды docker ps
При применении комманды   terraform apply -auto-approve  могут быть уничтожены существующие контейнеры. Команда не изменяет параметры существующих контейнеров а удаляет их и создает новые контейнеры.

root@TestDebian11:/opt/terraform# docker ps
CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS         PORTS                  NAMES
543c1ad37c66   a7be6198544f   "/docker-entrypoint.…"   6 minutes ago   Up 6 minutes   0.0.0.0:8000->80/tcp   example_9hC1T4SAmr5fOtxR


7. Уничтожьте созданные ресурсы с помощью terraform. Убедитесь, что все ресурсы удалены. Приложите содержимое файла terraform.tfstate.

Cодержимое файла terraform.tfstate:

{
  "version": 4,
  "terraform_version": "1.5.1",
  "serial": 1,
  "lineage": "588c7a1e-4160-ea7f-3598-ee075e54f992",
  "outputs": {},
  "resources": [],
  "check_results": null
}

8. Объясните, почему при этом не был удален docker образ nginx:latest ? Ответ подкрепите выдержкой из документации провайдера.

Docker образ не был удален потому что установлен параметр keep_locally = true

resource "docker_image" "nginx" {
  name         = "nginx:latest"
  keep_locally = true
}

Выдержка из документации:
keep_locally (Boolean) If true, then the Docker image won't be deleted on destroy operation. 
If this is false, it will delete the image from the docker local storage on destroy operation.


  
  
  

































**********************************************************************************************************************************************************************************************************************************
Домашнее задание "Введение. Экосистема. Архитектура. Жизненный цикл Docker контейнера"

Задача 2 


    высоконагруженное монолитное Java веб-приложение;
    - физическая машина
    Высокие требования к ресурсам сервера.
    
    Nodejs веб-приложение;
    - Docker-контейнеры
    Возможность регулировать количество контейнеров и тем самым экономно потреблять ресурсы в зависимости от нагрузки.
    
    мобильное приложение c версиями для Android и iOS;
    - Docker-контейнеры
    Возможность регулировать количество контейнеров и тем самым экономно потреблять ресурсы в зависимости от нагрузки.
    
    шина данных на базе Apache Kafka;
    - Виртуальная машина
    Возможность добавлять ресурсы по мере увеличения обьектов на шине.
    
    Elasticsearch-кластер для реализации логирования продуктивного веб-приложения — три ноды elasticsearch, два logstash и две ноды kibana;
    - Виртуальная машина
    Возможность добавлять ноды в кластере по мере увеличения нагрузки.
    
    мониторинг-стек на базе Prometheus и Grafana;
    - Виртуальная машина
    Возможность добавлять ноды в кластере по мере увеличения нагрузки.
    
    MongoDB как основное хранилище данных для Java-приложения;
    - физическая машина
    Высокие требования к ресурсам сервера.
    
    Gitlab-сервер для реализации CI/CD-процессов и приватный (закрытый) Docker Registry.
    - Docker-контейнеры
    Возможность регулировать количество контейнеров и тем самым экономно потреблять ресурсы в зависимости от нагрузки.

    Задача 3
    
root@TestDebian11:/opt/docker/data# docker exec -it idebian /bin/bash
root@08e0c12d16fa:/# cd data
root@08e0c12d16fa:/data# ls -lahi
total 16K
 32646 drwxr-xr-x 2 root root 4.0K May 25 15:55 .
318361 drwxr-xr-x 1 root root 4.0K May 25 15:46 ..
  8301 -rw-r--r-- 1 root root   43 May 25 15:55 container_centos_file.txt
  8290 -rw-r--r-- 1 root root   40 May 25 15:55 host_file.txt
root@08e0c12d16fa:/data# cat container_centos_file.txt 

This file was created in container centos
root@08e0c12d16fa:/data# cat host_file.txt             

 This file was created in host mashine
root@08e0c12d16fa:/data# 


*******************************************************************************************************************

Домашнее задание к занятию 2. «Применение принципов IaaC в работе с виртуальными машинами»

Задача 1
Опишите основные преимущества применения на практике IaaC-паттернов.
1. Скорость и уменьшение затрат
2. Масштабируемость и стандартизация.
3. Безопасность и документация.
4. Восстановление в аварийных ситуациях.


Какой из принципов IaaC является основополагающим?
Получение аналогичного результата при большом количестве повторных операций.

Задача 2

Чем Ansible выгодно отличается от других систем управление конфигурациями?
1. Быстрая настройка головного сервера (Нужно только скачать с Git репозиторий)
2. Для управления клиентам используется метод push который более надежен чем pull.
3. Модули могут быть написаны практически на любом языке (но пишутся чаще на Python)

Какой, на ваш взгляд, метод работы систем конфигурации более надёжный — push или pull?
Мне кажется что более надежный метод - push.
Причина - Этот метод выполняется с одного места поэтому легче контролировать на каких клиентах была выполнена комманда а на каких нет.

Задача 3

Вывод команд установленных версий каждой из програм.


VirtualBox -v
Комманда не работает. Вывод версии не возможен.

vagrant -v
Vagrant 2.2.14

terraform -v 
Terraform v1.4.6
on linux_amd64

ansible --version
ansible 2.10.8
  config file = None
  configured module search path = ['/root/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']
  ansible python module location = /usr/lib/python3/dist-packages/ansible
  executable location = /usr/bin/ansible
  python version = 3.9.2 (default, Feb 28 2021, 17:03:44) [GCC 10.2.1 20210110]



********************************************************************************************************************





Задача 1.

Основное отличие полной (аппаратной) виртуализации, паравиртуализации и виртуализации на основе ОС.

основное отличие полной (аппаратной) виртуализации, паравиртуализации и виртуализации на основе ОС - способ использования  ресурсов физического сервера операционными системами установленными на  виртуальных машинах.

Паравиртуализация -  Для создания виртуальной машины необходима операционная система в которой можно изменять настройки ядра для  взаимодействия с гипервизором.
При изменении  настроек ядра добавляются драйверы которые позволяют получить  доступ к ресурсам сервера через гипервизор напрямую. Нет необходимости эмулировать физические устройства. 

Полная (аппаратная) виртуализация - Для создания виртуальной машины подойдет практически любая операционная система. Изменения операционной системы не требуется.  Виртуальная машина эмулирует физический сервер. Для доступа к ресурсам физического сервера операционная система обращается к виртуальной машине, а виртуальная машина через гипервизор к физическому серверу.

Виртуализации на основе ОС - Для создания виртуальной машины нужна операционная система которая сможет взаимодействовать с ядром ОС которая установлена на физическом сервере. Для доступа к ресурсам физического сервера виртуальная машина обращается напрямую к серверу.

Задача 2.

Среда использования:
Высоконагруженная база данных, чувствительная к отказу.
Системы, выполняющие высокопроизводительные расчёты на GPU.

Выбор оборудования или среды виртуализации - Физические сервера 

Причина выбора - Прямой доступ к ресурсам сервера. Основной и во многих случаях единственный потребитель ресурсов сервера. Отсутствие других приложений которые конкурируют за доступ к ресурсам сервера.


Среда использования:
Windows-системы для использования бухгалтерским отделом.

Выбор оборудования или среды виртуализации - Паравиртуализация.

Причина выбора - Эфективное использование вычислительных ресурсов. Возможность быстрого создания виртуальных машин.


Среда использования:
Различные web-приложения.

Выбор оборудования или среды виртуализации - Виртуализация уровня ОС.

Причина выбора -  Возможность мгновенного создания типовых виртуальных машин. Хорошая производительность виртуальных машин за счет прямого доступа к ресурсам сервера.


Задача 3.

Сценарий 1.

100 виртуальных машин на базе Linux и Windows, общие задачи, нет особых требований. Преимущественно Windows based-инфраструктура, требуется реализация программных балансировщиков нагрузки, репликации данных и автоматизированного механизма создания резервных копий.

Система управления виртуализацией - VMware VSphere

Причина выбора -  Полноценная поддержка операционных систем Linux и Windows.
Возможность настройки репликации виртуальных машин, распределение нагрузки между физическими серверами, резервное копирование.


Сценарий 2.

Требуется наиболее производительное бесплатное open source-решение для виртуализации небольшой (20-30 серверов) инфраструктуры на базе Linux и Windows виртуальных машин.

Система управления виртуализацией - KVM

Причина выбора - Бесплатное. Кроссплатформеное.  


Сценарий 3.

Необходимо бесплатное, максимально совместимое и производительное решение для виртуализации Windows-инфраструктуры.

Система управления виртуализацией - KVM. (Не указал Hyper-V поскольку это приложение платное а в задаче одно из условий - бесплатное приложение )

Причина выбора - Бесплатное. Кроссплатформеное. 


Сценарий 4.

Необходимо рабочее окружение для тестирования программного продукта на нескольких дистрибутивах Linux.

Система управления виртуализацией - Oracle Virtual Box

Причина выбора - Легко установить и настроить. Можно установить на любой операционной системе.


Задача 4.

Проблемы и недостатки гетерогенной среды виртуализации
1 Высокая стоимость обслуживания. Неоходимы инженеры с навыками работы в нескольких средах виртуализации.
2 Более детальный подбор оборудования. Один сервер может подходить для одной среды виртуализации но не подходить для другой.
3 Проблемы взаимодействия между средами виртуализации. Невозможность организовать миграцию виртуальных машин, сетевую балансировку трафика.
4 Необходимость приобретения различного програмного обеспечения для резервного копирования виртуальных машин

Если бы у меня был выбор я бы не создавал гетерогенную среду виртуализации по указанным выше причинам.


